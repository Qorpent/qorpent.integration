((function(){
var u = require("underscore");
var repl = require("repl");
var fail = require("qpt-utils").fail;
var handleFile = require("qpt-utils").handleFile;
var fs = require("fs");
var qlaudify = function(library){
   return require("./extensions").setup(library);
} ;
var timestamp = require("qpt-utils").timestamp;

var prepareContext = function(context){
	context = context || {};
	context.options = context.options || (require("optimist").argv);
	context.options.mode  = context.options.mode || "repl";
    context.options.httpport = context.options.httpport || 8087;
	return context;
}

var onupdateModule = function(context){
  console.log("lib updated : ",context.moduleInfo);
};

//loads qlaud class library with QLAUD mapping
var load = module.exports.load = function( context, onload ) {
	context = prepareContext(context);
    if(!context.options.lib)throw new Error("library is not set");
    if(!context.options.libfile){
        context.options.libfile = handleFile(context.options.lib);
        context.options.libfile.on("change",function(){
           context.reload("file changed");
        });
    }
	var onloadlibrary = function(error, library){
		if( error ) fail (error, onload );
		context.qlaud = qlaudify (library);
        context.qlaud.host = context;
		if (onload ){
			onload ( null, context.qlaud );
		}
	};
	require("bsharp").loadlib(context.options,onloadlibrary);
};
var router = require("./http/router");
var httpHandler = {
    //dispatches http requests
    dispatch : function (context,req,res){
        try{
            res.setHeader("Server","QHS 0.1");
            var realhandler = router.route(context,req);
            if(null==realhandler){
                console.warn("unknown req: "+req.url);
                res.writeHead(404, {'Content-Type': 'text/plain'});
                res.end("Handler not found for given command");
            }else{
                if(typeof realhandler=="function"){
                    realhandler(context,req,res);
                }else{
                    if(realhandler.etag){
                        res.setHeader("ETag",realhandler.etag);
                        var oldetag = req.headers["if-none-match"];
                        if(oldetag==realhandler.etag){
                            res.writeHead("304");
                            res.end();
                            return;
                        }
                    }
                    res.writeHead(realhandler.state,{"Content-Type":realhandler.ctype});
                    res.end(realhandler.content);
                }
            }

        }catch(e){
            console.error("error in http: "+e);
            res.writeHead(500,{"Content-Type":"text/plain"});
            res.end("error:"+e);
        }
    }
};

// startup modes for qlaud
var serviceTypes = {
	//interactive console mode of qlaud
	repl : function (context, onservice) {
        if(context.isStarted){
            global.qlaud = context.qlaud;
            global.app = context;
            global.nodes =  u.bind(context.qlaud.nodes,context.qlaud);
            global.getnode = function(q){
                q = q || ("c:"+context.options.self);
                return u.first(context.qlaud.nodes(q));
            };
            global.mynode = function(){return global.getnode(context.options.self);};

            return;
        }
		console.log ("QLAUD IS STARTED IN REPL MODE, USE NATIVE API");
		global.u = require("underscore");
		global.qlaud = context.qlaud;
		global.app = context;
		global.nodes = u.bind(context.qlaud.nodes,context.qlaud);
		global.getnode = function(q){
			q = q || ("c:"+context.options.self);
			return u.first(context.qlaud.nodes(q));
		};
        global.mynode = function(){return global.getnode(context.options.self);};
		repl.start({prompt:"qld> ",useGlobal:true});
		if(onservice){
			onservice(null, context);
		}
	},
	//http server of claud-config
	http : function (context, onservice) {
        if(context.isStarted)return;
        console.log ("QLAUD IS STARTED IN HTTP MODE, USE REST API");
        var https = require('http');
        context.http = https.createServer(function(req,res){
             httpHandler.dispatch(context.qlaud,req,res);
        }).listen(context.options.httpport);
        console.log ("QHS HTTP Server started at http://localhost:"+context.options.httpport);
	},
	
	//bi-process http+udp config+sync service
	node : function (context ,onservice){
        this.http(context,null);
        this.repl(context,null);
        if(onservice){
            onservice(null, context);
        }
	},
	
	// just print required report about QLAUD
	report : function (context, onservice) {
		fail("report not configured yet",onservice);
	}

}


//run qlaud service in given mode
//onload library runs after qlaud library is setup and before configured service run
//onservice called when service created and started and full context will be returned there
var run = module.exports.run = function ( context,  onload , onservice ) {
	context = prepareContext(context);
    var _onload = onload;
	var onlibload = function (err, library,callback){
		if (err ) fail (err, _onload);
        _onload = _onload||callback;
		if (_onload) _onload (library);
		if (!serviceTypes[context.options.mode]){
			fail ( new Error("illegal start mode '"+context.options.mode+"'"),  onservice);
		}else{
			    serviceTypes[context.options.mode](context, onservice);
                context.options.libmodify = timestamp(fs.statSync(context.options.lib).mtime);
                if(context.isStarted){
                    console.log("reload finished");
                }else{
                    context.isStarted = true;
                    console.log("load and start finished");
                }
                var newmodule = context.qlaud.get("c:__module");
                newmodule.isnewer =function(othermodule){
                    if(null==othermodule)return true;
                    if(this.hash==othermodule.hash)return false;
                    return this.timestamp > othermodule.timestamp;
                };
                var oldmodule = context.moduleInfo;
                context.moduleInfo = newmodule;
                if(newmodule.isnewer(oldmodule)){
                    onupdateModule(context);
                }

		}
	}
    context.reload = function(cause,callback){
        if(cause){
            console.log("reload initiated due to: "+cause);
        }
        load(context,function(e,r){
            onlibload(e,r,_onload);
            if(null!=callback){
                callback(e,r);
            }
        })};

    context.restart = function(){
        if(this.http){
            console.log("close http");
            this.http.close();
        }
        var cp = require("child_process");
        var startup = "start node index.js --lib="+this.options.lib+" --mode="+this.options.mode;
        console.log(startup);
        cp.exec(startup);
        setTimeout(function(){
        process.exit();
        },1000);
    },


	load ( context,onlibload);

    global.reload = u.bind(context.reload,context);
};

})());