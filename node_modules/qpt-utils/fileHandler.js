/**
 * Created by comdiv on 15.12.13.
 */
var fs = require("fs");
var timestamp  = function(d){
    return (d||new Date()).toISOString().replace(/\D/g,'');
};
var u = require("underscore");
var ev = require("events");
module.exports = function(filename){
    var result = u.extend(new ev.EventEmitter(),  {
        name :filename,
        exists : function(callback){
            var self = this;
            if(!!callback){
               return fs.exists(this.name,function(result){
                   self._checkWatch(result);
                   callback(result);
               });
            }else{
               var result = fs.existsSync(this.name);
               self._checkWatch(result);
                return result;
            }
        },
        read : function(callback){
           this.__read_was_called = true;
           if(!this.__last_change) {
               if(this.exists()){
               this.__last_change = timestamp(fs.statSync(this.name).mtime);
               }else{
                   this.__last_change = timestamp(new Date(2000,1,1))
               }
           }
          if(!!callback){
              var self = this;
              this.exists(function(r){self._asyncRead(r,callback);});
          }  else{
              if(this.exists()){
                  return fs.readFileSync(this.name);
              }else{
                  return "";
              }
          }
        },
        readobj : function(callback){
            var self = this;
            if(!!callback){
                this.read(function(e,r){
                    if(e){
                        callback(e, {__iserror :true, error:e, content: null});
                    }else{
                        var result = self._readAsObj(r);
                        if(!!result.__iserror){
                            callback(result.error,result);
                        }else{
                            callback(null,result);
                        }
                    }
                });
            }else{
                try{
                    return this._readAsObj(this.read());
                }catch(e){
                    throw {__iserror :true, error:e, content: null};
                }
            }
        },
        _readAsObj : function(str){
            try{
                return JSON.parse(str);
            }  catch(e){
                return {__iserror :true, error:e, content: str};
            }
        },
        write : function(content, notifychange,callback){
            content = content||"";
            if(typeof content =="object"){
                content = JSON.stringify(content);
            }
            if(typeof notifychange=="function"){
                callback = notifychange;
                notifychange =false;
            }
            if(!notifychange){
                this.__last_change = timestamp();
            }
            if(!callback){
                fs.writeFileSync(this.name,content);
                this._checkWatch();
            }else{
                fs.writeFile(this.name,content,function(e,r){
                    this._checkWatch();
                    callback(e,r);
                });
            }
        },
        stopWatch : function(){
            if(null!=this._watch){
                this._watch.removeAllListeners("change");
                this._watch = null;
            }
        },
        _asyncRead : function(exists,callback){
            if(!exists){
                callback(null,"");
            }else{
                fs.readFile(this.name,callback);
            }
        },
        _checkWatch : function(e){
            if(e && !this._watch){
                this._watch = fs.watch(this.name,{persistent:false},this._onChange);
            }
        },
        _onChange:function(e,r){
            if(e!="change")return;
            try{
                //we don't spam change event if this file not read yet
                if(!this.__read_was_called)return;
                var oldlast = this.__last_change;
                var newlast = timestamp(fs.statSync(this.name).mtime);
                this.__last_change = newlast;
                //don't spam on repeated saves with time-set
                if((newlast-oldlast) >=30 ){
                    this.emit("change",this.__last_change);
                }
            }catch(e){
                this.stopWatch();
            }
        }
    });
    u.bindAll(result,"_asyncRead","read","exists","_checkWatch","_onChange","_readAsObj");
    result.exists();
    return result;
}